(function() {
  var APP_PATH, PLUGIN_NAME, Promise, TOOL_PATH, checkSketchTool, cleanSketch, fs, gutil, path, recursive, rimraf, spawn, temporary, through, which, yesOrNo;

  spawn = require('child_process').spawn;

  Promise = require('es6-promise').Promise;

  through = require('through2');

  fs = require('fs');

  path = require('path');

  gutil = require('gulp-util');

  temporary = require('temporary');

  cleanSketch = require('clean-sketch');

  recursive = require('recursive-readdir');

  rimraf = require('rimraf');

  which = require('npm-which')(process.cwd());

  PLUGIN_NAME = 'gulp-sketch';

  APP_PATH = '/Applications/Sketch.app';

  TOOL_PATH = APP_PATH + "/Contents/Resources/sketchtool/bin/sketchtool";

  yesOrNo = function(val) {
    return val === true || val === 'Yes' || val === 'yes' || val === 'YES';
  };

  checkSketchTool = (function() {
    var cmnd;
    cmnd = '';
    return function() {
      if (cmnd) {
        return Promise.resolve(cmnd);
      }
      return new Promise(function(resolve, reject) {
        return fs.access(TOOL_PATH, fs.F_OK, function(err) {
          if (!err) {
            resolve(TOOL_PATH);
            return;
          }
          return which('sketchtool', function(err2, pathTo) {
            if (err2) {
              return reject(new gutil.PluginError(PLUGIN_NAME, 'No sketchtool installed.'));
            } else {
              cmnd = pathTo;
              return resolve(cmnd);
            }
          });
        });
      });
    };
  })();

  module.exports = function(options) {
    var args;
    if (options == null) {
      options = {};
    }
    args = [];
    if (options["export"]) {
      args.push('export');
      args.push(options["export"]);
    }
    if (options.trimmed) {
      args.push('--trimmed=' + options.trimmed);
    }
    if (options.compression) {
      args.push('--compression=' + options.compression);
    }
    if (options.scales) {
      args.push('--scales=' + options.scales);
    }
    if (options.formats) {
      args.push('--formats=' + options.formats);
    }
    if (options.item) {
      args.push('--item=' + options.item);
    }
    if (yesOrNo(options.progressive)) {
      args.push('--progressive');
    }
    if (yesOrNo(options.compact)) {
      args.push('--compact');
    }
    if (options.background) {
      args.push('--background=' + options.background);
    }
    if (yesOrNo(options.groupContentsOnly)) {
      args.push('--group-contents-only');
    }
    if (options.items) {
      args.push('--items=' + options.items);
    }
    if (yesOrNo(options.saveForWeb)) {
      args.push('--save-for-web');
    }
    if (options.bounds) {
      args.push('--bounds=' + options.bounds);
    }
    options.clean = yesOrNo(options.clean);
    return through.obj(function(file, encoding, callback) {
      if (file.isStream()) {
        this.emit('error', new gutil.PluginError(PLUGIN_NAME, 'Streaming not supported'));
        return callback();
      }
      return checkSketchTool()["catch"](function(err) {
        this.emit('error', err);
        return callback();
      }).then((function(_this) {
        return function(cmnd) {
          var program, src, tmp_dir;
          src = file.path;
          tmp_dir = new temporary.Dir();
          if (options.outputJSON) {
            args.push('--outputJSON=' + tmp_dir.path + '/' + options.outputJSON);
          }
          program = spawn(cmnd, args.concat(src, '--output=' + tmp_dir.path));
          if (options.verbose) {
            program.stdout.on('data', function(data) {
              return gutil.log(data.toString());
            });
          }
          return program.stdout.on('end', function() {
            return recursive(tmp_dir.path, function(err, files) {
              var abs_path, b, f, i, len, rel_path;
              for (i = 0, len = files.length; i < len; i++) {
                abs_path = files[i];
                rel_path = path.relative(tmp_dir.path, abs_path);
                f = new gutil.File({
                  cwd: file.cwd,
                  base: file.base,
                  path: path.join(file.base, rel_path)
                });
                b = fs.readFileSync(abs_path);
                if (options.clean && /\.svg$/.test(rel_path)) {
                  b = new Buffer(cleanSketch(b.toString()));
                }
                f.contents = b;
                _this.push(f);
              }
              return rimraf(tmp_dir.path, function() {
                return callback();
              });
            });
          });
        };
      })(this));
    });
  };

}).call(this);
